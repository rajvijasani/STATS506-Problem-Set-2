---
title: "Problem Set 2"
author: "Rajvi Jasani"
format: 
  html:
    toc: true
    code-fold: true
    embed-resources: true
  pdf: default
---
## GitHub Repository

This is the link to my GitHub repository <https://github.com/rajvijasani/STATS506-Problem-Set-2.git>

## Problem 1 - Dice Game

a.
```{r}
#' Function to calculate total winnings version 1 (using a loop)
#'
#' @param n number of rolls
#' @param seed to control randomization (if a value is provided)
#'
#' @return total winnings
play_dice_v1 <- function(n, seed = NULL) {
  if (n < 0) {
    # checking for a negative input and showing appropriate error
    stop("number of rolls must be positive")
  }
  if (n == 0) {
    # if no die is rolled (game is not played), winnings=0
    return(0)
  }
  set.seed(seed)
  rolls <- sample(1:6, n, replace = TRUE)
  winnings <- 0
  
  for (i in rolls) {
    # -2 for the cost of a roll
    winnings <- winnings - 2
    if (i == 3 | i == 5) {
      winnings <- winnings + (i * 2)
    }
    # any other roll wins nothing
  }
  return(winnings)
}

#' Function to calculate total winnings version 2 (using vectorization)
#'
#' @param n number of rolls
#' @param seed to control randomization (if a value is provided)
#'
#' @return total winnings
play_dice_v2 <- function(n, seed = NULL) {
  if (n < 0) {
    # checking for a negative input and showing appropriate error
    stop("number of rolls must be positive")
  }
  if (n == 0) {
    # if no die is rolled (game is not played), winnings=0
    return(0)
  }
  set.seed(seed)
  rolls <- sample(1:6, n, replace = TRUE)
  winnings <- 0
  # desired_rolls is a logical vector which stores
  # TRUE if a roll is 3 or 5 and FALSE otherwise
  desired_rolls <- (rolls == 3 | rolls == 5)
  # multiplying each roll with corresponding logical value and 2
  # [TRUE->1; FALSE->0]
  # and subtracting cost of roll
  # if roll is 3, (3*1*2)-2=4
  # if roll is 6, (6*0*2)-2=-2
  winnings_per_roll <- rolls * desired_rolls * 2 - 2
  return(sum(winnings_per_roll))
}

#' Function to calculate total winnings version 3 (using table function)
#'
#' @param n number of rolls
#' @param seed to control randomization (if a value is provided)
#'
#' @return total winnings
play_dice_v3 <- function(n, seed = NULL) {
  if (n < 0) {
    # checking for a negative input and showing appropriate error
    stop("number of rolls must be positive")
  }
  if (n == 0) {
    # if no die is rolled (game is not played), winnings=0
    return(0)
  }
  set.seed(seed)
  rolls <- sample(1:6, n, replace = TRUE)
  winnings <- 0
  # collecting the frequencies of rolls in a table form
  # factor() is used to include levels which have frequency=0 in the table
  rolls_count <- table(factor(rolls, levels = c(1, 2, 3, 4, 5, 6)))
  # as.numeric is used to only extract the frequency from the table
  winnings <- as.numeric(rolls_count[3]) * 6 + as.numeric(rolls_count[5]) * 10 - n * 2
  return(winnings)
}

#' Function to calculate total winnings version 4 (using vapply function)
#'
#' @param n number of rolls
#' @param seed to control randomization (if a value is provided)
#'
#' @return total winnings
play_dice_v4 <- function(n, seed = NULL) {
  if (n < 0) {
    # checking for a negative input and showing appropriate error
    stop("number of rolls must be positive")
  }
  if (n == 0) {
    # if no die is rolled (game is not played), winnings=0
    return(0)
  }
  set.seed(seed)
  rolls <- sample(1:6, n, replace = TRUE)
  winnings <- 0
  # applying function to return winnings (except cost of roll) of each roll
  # on all samples in the rolls vector,
  # summing the winnings and subtracting the costs all of rolls
  winnings <- sum(vapply(rolls, function(i) {
    if (i == 3 | i == 5) {
      return(i * 2)
    }
    return(0)
  }, 1)) - (n * 2)
  return(winnings)
}
```
*Attribution of source for v3:* Used ChatGPT to find a function to get the frequencies for all levels (even if they are zero) AND to find a function to only extract the frequency (without the name of level)

b.

Version 1
```{r}
c(play_dice_v1(3), play_dice_v1(3000))
```
Version 2
```{r}
c(play_dice_v2(3), play_dice_v2(3000))
```
Version 3
```{r}
c(play_dice_v3(3), play_dice_v3(3000))
```
Version 4
```{r}
c(play_dice_v4(3), play_dice_v4(3000))
```

c.

Results for n = 3, seed = 223
```{r}
c(
  play_dice_v1(3, seed = 223),
  play_dice_v2(3, seed = 223),
  play_dice_v3(3, seed = 223),
  play_dice_v4(3, seed = 223)
)
```

Results for n = 3000, seed = 223
```{r}
c(
  play_dice_v1(3000, seed = 223),
  play_dice_v2(3000, seed = 223),
  play_dice_v3(3000, seed = 223),
  play_dice_v4(3000, seed = 223)
)
```

d.

Comparison of speeds with n = 1000
```{r}
library(microbenchmark)
microbenchmark(
  version1 = play_dice_v1(1000, seed = 223),
  version2 = play_dice_v2(1000, seed = 223),
  version3 = play_dice_v3(1000, seed = 223),
  version4 = play_dice_v4(1000, seed = 223)
)
```
We see that there is only a small difference in speeds of version 1 (loop) and version 3 (table). Version 4 (vapply) is the slowest whereas version 2 (vectorization) is the fastest as expected. 

Comparison of speeds with n = 100000
```{r}
microbenchmark(
  version1 = play_dice_v1(100000, seed = 223),
  version2 = play_dice_v2(100000, seed = 223),
  version3 = play_dice_v3(100000, seed = 223),
  version4 = play_dice_v4(100000, seed = 223)
)
```
As number of rolls increased, we can see a significant difference in speeds of version 1 (loop) and version 3 (table) which tells us that loops are not speed-wise efficient for big samples whereas tables, second fastest approach, can be useful for big samples. Version 4 (vapply) is still the slowest by a large margin whereas version 2 (vectorization) is the fastest as expected.

e. 

We will be running 3 simulations of 10000 trials each but with different number of rolls just to be sure that number of rolls does not affect the winnings drastically.
```{r}
# number of trials to run
trials <- 10000
# we will be running 3 different simulations with different number of rolls in each just to be sure
# vectors to save winning amounts (or losses) of each trail
all_winnings_1 <- vector(length = trials)
all_winnings_2 <- vector(length = trials)
all_winnings_3 <- vector(length = trials)
for (i in 1:trials) {
  # simulation with 10 rolls in each trial
  all_winnings_1[i] <- play_dice_v2(10)
  # simulation with 100 rolls in each trial
  all_winnings_2[i] <- play_dice_v2(100)
  # simulation with 1000 rolls in each trial
  all_winnings_3[i] <- play_dice_v2(1000)
}
c(mean(all_winnings_1),
  mean(all_winnings_2),
  mean(all_winnings_3))
```
Each simulation gives a positive mean, i.e. over 10000 trials of 10, 100, or 1000 rolls, the player tends to win money on average. This makes the game biased towards the player, thus unfair. A fair game should have an average around 0, i.e. no gain no loss.